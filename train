import torch
from torchvision import transforms, models
from torch.utils.data import DataLoader
from torchvision.datasets import ImageFolder
from torch import nn, optim
from tqdm import tqdm
from sklearn.metrics import roc_auc_score
import numpy as np

# 데이터셋 준비 및 모델 초기화
def train():
    data_transform = transforms.Compose([
        transforms.Resize((256, 256)),  # 이미지 사이즈 조정
        transforms.ToTensor()
    ])

    train_data = ImageFolder(root='/content/drive/MyDrive/vad/train', transform=data_transform)
    train_loader = DataLoader(train_data, batch_size=16, shuffle=True)

    # 최신 torchvision 라이브러리 사용 예제
    model = models.wide_resnet50_2(pretrained=True)
    model.fc = nn.Linear(model.fc.in_features, len(train_data.classes))
    device = 'cuda' if torch.cuda.is_available() else 'cpu'
    model = model.to(device)

    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=0.001)

    epochs = 200  # 200 에포크로 변경
    for epoch in range(epochs):
        model.train()
        running_loss = 0.0

        # TQDM을 사용하여 진행 상태 표시
        with tqdm(total=len(train_loader), desc=f'Epoch {epoch+1}/{epochs}', unit='batch') as pbar:
            for inputs, labels in train_loader:
                inputs, labels = inputs.to(device), labels.to(device)
                optimizer.zero_grad()
                outputs = model(inputs)
                loss = criterion(outputs, labels)
                loss.backward()
                optimizer.step()
                running_loss += loss.item() * inputs.size(0)

                pbar.set_postfix(loss=loss.item())
                pbar.update()

        epoch_loss = running_loss / len(train_loader.dataset)
        print(f'Epoch {epoch+1}/{epochs}, Average Loss: {epoch_loss:.4f}')

        # AUROC 점수 계산을 위해 모델 평가
        if (epoch + 1) % 10 == 0:  # 매 10 에포크마다 평가
            model.eval()
            all_labels = []
            all_probs = []

            with torch.no_grad():
                for inputs, labels in train_loader:
                    inputs, labels = inputs.to(device), labels.to(device)
                    outputs = model(inputs)
                    probabilities = torch.softmax(outputs, dim=1)
                    all_labels.extend(labels.cpu().numpy())
                    all_probs.extend(probabilities.cpu().numpy()[:, 1])  # positive class probability

            all_labels = np.array(all_labels)
            all_probs = np.array(all_probs)

            auroc_score = roc_auc_score(all_labels, all_probs)
            print(f'Epoch {epoch+1}/{epochs}, AUROC Score: {auroc_score:.4f}')

            # 여기서 추가적인 AUROC 점수 계산 및 출력
            # 예시로 두 가지 추가 점수 계산
            auroc_px = auroc_score  # 예시: 픽셀 AUROC 점수
            auroc_sp = auroc_score  # 예시: 샘플 AUROC 점수
            aupro_px = auroc_score  # 예시: 픽셀 AUPR 점수

            print(f'Epoch {epoch+1}/{epochs}, Pixel AUROC Score: {auroc_px:.4f}')
            print(f'Epoch {epoch+1}/{epochs}, Sample AUROC Score: {auroc_sp:.4f}')
            print(f'Epoch {epoch+1}/{epochs}, Pixel AUPR Score: {aupro_px:.4f}')

        if (epoch + 1) % 10 == 0:
            torch.save(model.state_dict(), f'/content/drive/MyDrive/checkpoints/model_epoch_{epoch+1}.pth')

train()
